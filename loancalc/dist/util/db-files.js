"use strict";var __awaiter=this&&this.__awaiter||function(a,b,c,d){return new(c||(c=Promise))(function(e,f){function g(a){try{i(d.next(a))}catch(a){f(a)}}function h(a){try{i(d["throw"](a))}catch(a){f(a)}}function i(a){a.done?e(a.value):new c(function(b){b(a.value)}).then(g,h)}i((d=d.apply(a,b||[])).next())})};Object.defineProperty(exports,"__esModule",{value:!0});const serve_1=require("../serve"),cursor_util_1=require("./cursor-util"),Path=require("path"),FileSystem=require("mz/fs"),config=require("config"),util_1=require("./util"),util_2=require("../graph/util"),FILE_REFERENCES={profiles:"profile_img",clients:"branding_img"};exports.DIRECTORY_MAP=Object.freeze({uploads:config.get("server.uploadDir")});function resolveMappedDir(a,b){return exports.DIRECTORY_MAP[a]?Path.resolve(exports.DIRECTORY_MAP[a],b):null}exports.resolveMappedDir=resolveMappedDir;function markNonexistentFilesForDeletion(){return __awaiter(this,void 0,void 0,function*(){serve_1.Logger.info("Marking DB files with no disk file (ghost DB files) as garbage.");let a=0,b=0;const c="SELECT id, directory, filename FROM db_files WHERE garbage = FALSE AND id > $1 ORDER BY id ASC LIMIT 100;";for(let d=yield serve_1.db.manyOrNone(c,b),e=[];d&&0<d.length;){let f=null;for(const a of d){const b=resolveMappedDir(a.directory,a.filename);b?(yield FileSystem.exists(b))?serve_1.Logger.debug("found: %s (id = %d)",b,a.id):(serve_1.Logger.debug("failed to find: %s",b),e.push(a.filename)):(serve_1.Logger.debug("bad filepath for dir: %s, filename: %s",a.directory,a.filename),e.push(a.filename)),f=a}f&&(b=f.id),0<e.length&&(yield util_1.batchAsync(e,16,(a)=>__awaiter(this,void 0,void 0,function*(){const b=util_2.multipleParamString(a);yield serve_1.db.tx((c)=>{const d=[c.none(`UPDATE db_files SET garbage = TRUE WHERE filename IN (${b});`,a)];for(const e in FILE_REFERENCES){const f=FILE_REFERENCES[e];d.push(c.none(`UPDATE ${e} SET ${f} = NULL WHERE ${f} IN (${b})`,a))}return c.batch(d)})})),a+=e.length,e.length=0),d=yield serve_1.db.manyOrNone(c,b)}serve_1.Logger.info("Finished marking %d ghost DB files.",a)})}function markUnreferencedFilesForDeletion(a){return __awaiter(this,void 0,void 0,function*(){serve_1.Logger.info("Marking DB files created before: %s",a.format("LLL"));let b=`
        UPDATE db_files file
        SET garbage = TRUE
        WHERE
            garbage = FALSE AND
            created < $1::timestamptz
    `,c=0;for(let a in FILE_REFERENCES){const d=FILE_REFERENCES[a],e="tb"+c;b+=`AND NOT EXISTS (SELECT 1 FROM ${a} ${e} WHERE ${e}.${d} = file.filename)`,c++}b+=";";const d=yield serve_1.db.result(b,[a.format()]);serve_1.Logger.info("Marked %d files for deletion.",d.rowCount)})}function deleteMarkedFilesFromDisk(){return __awaiter(this,void 0,void 0,function*(){yield cursor_util_1.useCursor((a)=>__awaiter(this,void 0,void 0,function*(){let b;for(const c=a.iterator(100);b=yield c.next();)for(const a of b){const b=resolveMappedDir(a.directory,a.filename);if(b){serve_1.Logger.verbose("Deleting marked file %s/%s (tag: %s) (path: %s)",a.directory,a.filename,a.tag,b);try{(yield FileSystem.exists(b))&&(yield FileSystem.unlink(b))}catch(a){serve_1.Logger.error("Failed to delete file %s: e",b,a)}}else serve_1.Logger.error("Could not resolve marked file %s/%s (tag: %s)",a.directory,a.filename,a.tag)}}),"SELECT * FROM db_files WHERE garbage = TRUE;",[])})}function garbageCollectFilesDB(){return __awaiter(this,void 0,void 0,function*(){const a=yield serve_1.db.result(`
        DELETE FROM db_files
        WHERE garbage;
    `);serve_1.Logger.info("Deleted %d files from the database.",a.rowCount)})}function pruneFiles(a){return __awaiter(this,void 0,void 0,function*(){serve_1.Logger.info("Pruning files before %s",a.format("LLL")),yield markNonexistentFilesForDeletion(),yield markUnreferencedFilesForDeletion(a),yield deleteMarkedFilesFromDisk(),yield garbageCollectFilesDB(),serve_1.Logger.info("Finished pruning files.")})}exports.pruneFiles=pruneFiles;function reserveFile(a,b,c){return __awaiter(this,void 0,void 0,function*(){16<b.length?b="."+b.substr(0,16):0<b.length&&(b="."+b);const{filename:d}=yield serve_1.db.one(`
        INSERT INTO db_files(directory, filename, tag)
        VALUES ($1, uuid_generate_v4()::varchar(53) || $2, $3)
        RETURNING filename;
    `,[a,b,c]);return serve_1.Logger.verbose("Reserved filename \"%s\" with tag \"%s\"",d,c),d})}exports.reserveFile=reserveFile;function checkFileTag(a){return __awaiter(this,void 0,void 0,function*(){const b=yield serve_1.db.oneOrNone(`
        SELECT tag FROM db_files
        WHERE filename = $1;
    `,a);return b&&b.tag||void 0})}exports.checkFileTag=checkFileTag;