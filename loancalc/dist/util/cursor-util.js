"use strict";var __awaiter=this&&this.__awaiter||function(a,b,c,d){return new(c||(c=Promise))(function(e,f){function g(a){try{i(d.next(a))}catch(a){f(a)}}function h(a){try{i(d["throw"](a))}catch(a){f(a)}}function i(a){a.done?e(a.value):new c(function(b){b(a.value)}).then(g,h)}i((d=d.apply(a,b||[])).next())})};Object.defineProperty(exports,"__esModule",{value:!0});const serve_1=require("../serve"),uuidv4=require("uuid/v4"),REQUIRE_EXPLICIT_OPEN=!1;var CommitState;(function(a){a[a.NONE=0]="NONE",a[a.COMMITTED=1]="COMMITTED",a[a.ROLLEDBACK=2]="ROLLEDBACK"})(CommitState=exports.CommitState||(exports.CommitState={}));class CursorIterator{constructor(a,b){this.cursor=a,this.step=b}next(){return __awaiter(this,void 0,void 0,function*(){return this.results=yield this.cursor.forward(this.step),this.results&&0<this.results.length?this.results:null})}}exports.CursorIterator=CursorIterator;class Cursor{constructor(a,b){this.__task=a,this.__name=b,this.__declared=!1,this.__closed=!0,this.__commitState=CommitState.NONE,this.nameP=[this.__name]}get task(){return this.__task}get name(){return this.__name}iterator(a){return new CursorIterator(this,a)}get commitState(){return this.__commitState}commit(){if(this.__commitState!==CommitState.NONE)throw new Error(`Attempted to commit an already committed or rolledback cursor(${this.__name}).`);this.__commitState=CommitState.COMMITTED}rollback(){if(this.__commitState!==CommitState.NONE)throw new Error(`Attempted to commit an already committed or rolledback cursor(${this.__name}).`);this.__commitState=CommitState.ROLLEDBACK}next(){return this.ensureUseable(),this.__task.oneOrNone("FETCH NEXT FROM $1~;",this.nameP)}prior(){return this.ensureUseable(),this.__task.oneOrNone("FETCH PRIOR FROM $1~;",this.nameP)}first(){return this.ensureUseable(),this.__task.oneOrNone("FETCH FIRST FROM $1~;",this.nameP)}last(){return this.ensureUseable(),this.__task.oneOrNone("FETCH FIRST FROM $1~;",this.nameP)}absolute(a){return this.ensureUseable(),this.__task.oneOrNone("FETCH ABSOLUTE $2 FROM $1~;",[this.__name,a])}relative(a){return this.ensureUseable(),this.__task.oneOrNone("FETCH RELATIVE $2 FROM $1~;",[this.__name,a])}count(a){return this.ensureUseable(),this.__task.manyOrNone("FETCH $2 FROM $1~;",[a])}all(){return this.ensureUseable(),this.__task.manyOrNone("FETCH ALL FROM $1~;",this.nameP)}forward(a){if("number"==typeof a)return this.__task.manyOrNone("FETCH FORWARD $2 FROM $1~;",[this.__name,a]);if("string"==typeof a&&"all"===a)return this.__task.manyOrNone("FETCH FORWARD ALL FROM $1~;",this.nameP);if(!a)return this.__task.oneOrNone("FETCH FORWARD FROM $1~;",this.nameP);throw new Error(`Invalid value for count in forward fetch: ${a}`)}backward(a){if("number"==typeof a)return this.__task.manyOrNone("FETCH BACKWARD $2 FROM $1~;",[this.__name,a]);if("string"==typeof a&&"all"===a)return this.__task.manyOrNone("FETCH BACKWARD ALL FROM $1~;",this.nameP);if(!a)return this.__task.oneOrNone("FETCH BACKWARD FROM $1~;",this.nameP);throw new Error(`Invalid value for count in backward fetch: ${a}`)}get isClosed(){return this.__closed}declare(a,b,c){return __awaiter(this,void 0,void 0,function*(){if(this.__declared)throw new Error(`Attempted to declare already declared cursor(${this.__name}).`);let d;if(!c)d="";else if("scroll"===c.toLowerCase())d=" SCROLL";else if("noscroll"===c.toLowerCase())d=" NOSCROLL";else throw new Error(`Bad scroll option: ${c}`);const e=(b?b.length:0)+1,f=b?b.concat([this.__name]):[this.__name];serve_1.Logger.info("params: ",f),yield this.__task.none(`
            DECLARE $${e}~ CURSOR${d} FOR ${a}
        `,f),this.__declared=!0})}open(){return __awaiter(this,void 0,void 0,function*(){if(!this.__declared)throw new Error(`Attempted to open undeclared cursor(${this.__name}).`);if(!this.__closed)throw new Error(`Attempted to open already open cursor(${this.__name}).`);REQUIRE_EXPLICIT_OPEN,this.__closed=!1})}close(){return __awaiter(this,void 0,void 0,function*(){if(!this.__declared)throw new Error(`Attempted to close undeclared cursor(${this.__name}).`);if(this.__closed)throw new Error(`Attempted to close already closed cursor(${this.__name}).`);yield this.__task.none("CLOSE $1~;",this.nameP),this.__closed=!0})}ensureUseable(){if(this.__commitState===CommitState.COMMITTED)throw new Error(`Attempted to use an already committed cursor(${this.__name}).`);if(this.__commitState===CommitState.ROLLEDBACK)throw new Error(`Attempted to use an already rolledback cursor(${this.__name}).`);if(!this.__declared||this.__closed)throw new Error(`Attempted to use an unopened cursor(${this.__name}).`)}}exports.Cursor=Cursor;function createCursorName(){return uuidv4()}function useCursor(a,b,c,d){return __awaiter(this,void 0,void 0,function*(){return serve_1.db.task((e)=>__awaiter(this,void 0,void 0,function*(){const f=(d?d.cursorName:null)||createCursorName(),g=(d?d.scroll:null)||null,h=new Cursor(e,f);let i=!1,j=!0;try{yield e.none("BEGIN;"),yield h.declare(b,c,g),yield h.open(),yield a(h),yield h.close(),h.commitState===CommitState.COMMITTED?yield e.none("COMMIT;"):yield e.none("ROLLBACK"),j=!1}catch(a){i=a}if(!h.isClosed)try{yield h.close()}catch(a){serve_1.Logger.error("Failed to force close cursor(%s): ",a)}if(j)try{yield e.none("ROLLBACK;")}catch(a){serve_1.Logger.error("Failed to force rollback cursor(%s): ",a)}if(i)throw i}))})}exports.useCursor=useCursor;