"use strict";var __awaiter=this&&this.__awaiter||function(a,b,c,d){return new(c||(c=Promise))(function(e,f){function g(a){try{i(d.next(a))}catch(a){f(a)}}function h(a){try{i(d["throw"](a))}catch(a){f(a)}}function i(a){a.done?e(a.value):new c(function(b){b(a.value)}).then(g,h)}i((d=d.apply(a,b||[])).next())})};Object.defineProperty(exports,"__esModule",{value:!0});const amqp=require("amqplib"),serve_1=require("../serve"),PRIORITIES={low:0,normal:1,high:2,critical:8};function isMessageData(a){return a?"string"==typeof a.type:a}class Message{constructor(a,b,c,d=0){this.key=a,this.data={payload:c,type:b,currentTry:d},this.metadata={priority:PRIORITIES.normal,persistent:!0}}getData(){return this.data}getKey(){return this.key}getMetadata(){return this.metadata}serialize(){return new Buffer(JSON.stringify(this.data))}retry(a){return this.data.retries=a,this}ttl(a){return this.metadata.expires=a,this}priority(a){return this.metadata.priority=PRIORITIES[a],this}persistent(a){return this.metadata.persistent=a,this}}exports.Message=Message;class MessageSender{constructor(a,b){this.preconnectQueue=[],this.ready=!1,this.connection=a,this.options=b}static createInstance(){return __awaiter(this,arguments,void 0,function*(){let a,b,c;if(1===arguments.length)c=arguments[0];else if(2===arguments.length)a=arguments[0],c=arguments[1];else if(3<=arguments.length)a=arguments[0],b=arguments[1],c=arguments[2];else throw new Error(`Bad arguments count passed to Message Sender constructor. (count: ${arguments.length})`);const d=yield createAMQPConnection(a,b);return new MessageSender(d,c)})}init(){return __awaiter(this,void 0,void 0,function*(){const a=yield this.connection.createChannel();this.channel=a,a.assertExchange(this.options.exchange,this.options.exchangeType||"direct",this.options.exchangeOptions),this.ready=!0,this.send=this.sendReady,this.flushPreconnectQueue()})}send(a){return this.ready?this.sendReady(a):(this.preconnectQueue.push(a),!0)}sendReady(a){return this.channel.publish(this.options.exchange,a.getKey(),a.serialize(),a.getMetadata())}flushPreconnectQueue(){for(const a of this.preconnectQueue)this.sendReady(a);this.preconnectQueue=null}}exports.MessageSender=MessageSender;class MessageReceiver{static createInstance(){return __awaiter(this,arguments,void 0,function*(){let a,b,c;if(1===arguments.length)c=arguments[0];else if(2===arguments.length)a=arguments[0],c=arguments[1];else if(3<=arguments.length)a=arguments[0],b=arguments[1],c=arguments[2];else throw new Error(`Bad arguments count passed to Message Sender constructor. (count: ${arguments.length})`);const d=yield createAMQPConnection(a,b);return new MessageReceiver(d,c)})}constructor(a,b){this.connection=a,this.options=b}init(){return __awaiter(this,void 0,void 0,function*(){const a=yield this.connection.createChannel();this.channel=a,yield a.assertExchange(this.options.exchange,this.options.exchangeType||"direct",this.options.exchangeOptions);const b=yield a.assertQueue(this.options.queue,this.options.queueOptions);this.queue=b.queue;const c=(c)=>__awaiter(this,void 0,void 0,function*(){if("string"==typeof c)serve_1.Logger.debug("AMQP binding pattern %s to exchange %s and queue %s",c,this.options.exchange,b),yield a.bindQueue(b.queue,this.options.exchange,c);else if(Array.isArray(c))for(const d of c)serve_1.Logger.debug("AMQP binding pattern %s to exchange %s and queue %s",d,this.options.exchange,b),yield a.bindQueue(b.queue,this.options.exchange,d);else if(c)throw Error("Unsupported pattern type. Must be a string or an array of strings.")});c(this.options.pattern),c(this.options.patterns)})}consume(a){this.channel.consume(this.queue,(b)=>{if(b)try{const c=b.content.toString("utf-8"),d=JSON.parse(c);a(d)}catch(a){serve_1.Logger.info("MESSAGE",b),serve_1.Logger.error("Error parsing message: ",a)}},{noAck:!0})}}exports.MessageReceiver=MessageReceiver;function createAMQPConnection(a,b){return __awaiter(this,void 0,void 0,function*(){const c=yield amqp.connect(`amqp://${a?a:"localhost"}${b?":"+b:""}`);return c})}exports.createAMQPConnection=createAMQPConnection;